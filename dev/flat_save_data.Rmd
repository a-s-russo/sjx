---
title: "Comparison of seasonal adjustment and trending methods on Australian data"
author: "Anthony Russo"
date: "`r Sys.Date()`"
output: html_document
---

```{r libraries, eval=FALSE, include=FALSE, message=FALSE, warning=FALSE}
library("dplyr")
library("ggplot2")
library("ggtext")
library("httr")
library("janitor")
library("lubridate")
library("readxl")
library("reshape2")
library("RJDemetra")
library("seasonal")
library("stringr")
library("zoo")
```

```{r function-download_ts, eval=FALSE}
#' @title
#' Download and clean ABS time series data
#' 
#' @description
#' `download_ts` downloads the time series data corresponding to a table of an
#' ABS publication, imports them into R, cleans and reformats the data, and
#' then returns a list containing tibbles of the series data and series
#' metadata.
#'
#' @details
#' The URL needs to be a link to the downloadable Excel file corresponding to a
#' table on the webpage of an ABS publication, and not a link to the webpage
#' itself. To obtain such a link (in Windows and using Microsoft Edge), navigate
#' to the 'Data downloads' tab of a publication, right-click on the 'Download
#' XLSX' hyperlink for the chosen table, and select 'Copy link'.
#' 
#' The included series start and end variables in the metadata ('Index' sheet of
#' the downloaded spreadsheet) are ignored. The reason is because some series
#' values in the data ('Data1' sheet) are suppressed or missing at the start
#' and/or end of the series, meaning these included variables don't align with
#' what's really in the data sheet containing the time series values.
#' 
#' For original series, only the most recent 500 observations are read in, as
#' X-13ARIMA-SEATS will fail to execute if the series are too long. Similarly,
#' any original series that are too short to be seasonally adjusted and trended
#' by X-13ARIMA-SEATS (that is, series containing less than three year's worth
#' of data) are removed from the returned datasets.
#' 
#' Some original series may have suppressed or missing values in the middle of
#' their span. These series are also removed since seasonally adjusted and trend
#' estimates cannot be generated from them by X-13ARIMA-SEATS or JDemetra+ due
#' to the missingness.
#' 
#' (ABS seasonally adjusted and trend series that are too short or contain
#' suppressed or missing values are retained since these only need to be
#' compared or displayed. They are also not restricted to the most recent 500
#' observations in the returned dataset.)
#' 
#' Any seasonally adjusted and trend series that do not have a corresponding
#' original series in the ABS data are also removed. This is because seasonally
#' adjusted and trend estimates cannot be generated without an original series,
#' obviously, so there is nothing to compare or display. (Therefore, if an
#' original series is removed because it is too short or contains missingness
#' in the middle as described above, then its corresponding seasonally adjusted
#' and trend series will also be removed.)
#'
#' @param url The download link to the data
#' 
#' @importFrom dplyr all_of any_of filter first last mutate rename select select_if slice_tail
#' @importFrom httr http_error
#' @importFrom janitor clean_names
#' @importFrom lubridate month quarter year ymd
#' @importFrom readxl excel_sheets read_excel
#' @importFrom rlang .data
#' @importFrom stats na.omit
#' @importFrom utils download.file
#' @importFrom zoo na.trim
#' 
#' @return The series data and metadata
#' 
#' @examples
#' # Construct a URL to download ABS data
#' ABS <- "https://www.abs.gov.au/statistics/economy/" # ABS website (for economic statistics)
#' pub <- "business-indicators/business-indicators-australia/" # Publication
#' ref <- "jun-2023/" # Reference period
#' cat <- "567600" # Catalogue number
#' tab <- "3" # Table number
#' ext <- ".xlsx" # File extension
#' URL <- paste0(ABS, pub, ref, cat, tab, ext)
#' 
#' # Download the series data and metadata
#' inventories <- download_ts(URL)
#' 
#' @export
download_ts <- function(url) {
  # Check for valid URL
  stopifnot("The URL is not a string" = is.character(url) == TRUE)
  stopifnot("The URL could not be found" = !http_error(url) == TRUE)
  stopifnot("The URL does not link to the ABS website" = startsWith(url, "https://www.abs.gov.au/"))
  stopifnot("The URL does not link to a data download file on the ABS website" = endsWith(url, ".xlsx"))
  
  # Initiate messages vector
  messages <- character(0)
  
  # Download data spreadsheet
  raw_data <- tempfile(fileext = ".xlsx")
  download.file(url,
                raw_data,
                method = "auto",
                mode = "wb",
                quiet = TRUE)
  stopifnot(
    "The 'Index' and/or 'Data1' sheets were not found in the downloaded ABS spreadsheet file" = all(c("Index", "Data1") %in% excel_sheets(raw_data))
  )
  
  # Read in series metadata
  series_metadata <-
    read_excel(
      raw_data,
      sheet = "Index",
      skip = 9,
      col_names = TRUE,
      .name_repair = "unique_quiet"
    )
  
  # Clean series metadata
  series_metadata <- series_metadata |>
    select_if(~!all(is.na(.))) |> # Discard empty columns
    na.omit() |> # Discard junk (empty and copyright) rows; note this must come after discarding any empty columns!
    clean_names() |>
    mutate(
      freq_name = .data$freq,
      freq_num = ifelse(
        .data$freq == "Quarter",
        4,
        ifelse(.data$freq == "Month", 12, NA)
      )
    ) |>
    select(-c(
      "series_start",
      "series_end",
      "freq",
      "no_obs",
      "collection_month",
      "data_type"
    )) # Drop start and end variables since these do not always exclude periods with suppressed or missing observations
  
  # Check that series are either monthly or quarterly
  freq_num <- unique(series_metadata$freq_num)
  stopifnot("The frequency of each series must be the same" = length(freq_num) == 1)
  freq_name <- tolower(unique(series_metadata$freq_name))
  stopifnot(
    "The downloaded ABS spreadsheet file contains series of frequencies other than monthly or quarterly" = freq_num %in% c(4, 12)
  )
  
  # Check for the existence of only original series in the initially downloaded spreadsheet file before any data cleaning
  orig_msg_flag <-
    FALSE # Existence of only original series also checked later after data cleaning, so don't warn twice
  if (length(setdiff(series_metadata$series_type, "Original")) == 0) {
    messages <-
      c(messages,
        "The downloaded ABS spreadsheet file only contains original series")
    orig_msg_flag <- TRUE
  }
  
  # Check for the existence of only seasonally adjusted and/or trend series in the initially downloaded spreadsheet file before any data cleaning
  stopifnot(
    "The downloaded ABS spreadsheet file does not contain any original series" = "Original" %in% unique(series_metadata$series_type)
  )
  
  # Read series data sheet
  series_data <- read_excel(raw_data, sheet = "Data1", skip = 9) |>
    rename(period = "Series ID") |>
    mutate(period = as.Date(.data$period))
  
  # Remove series for which all observations are suppressed or missing
  empty_series <- colnames(select_if(series_data, ~all(is.na(.))))
  series_data <- select(series_data, -(all_of(empty_series)))
  stopifnot(
    "After removing series for which all observations are suppressed or missing, no series exist in the series data sheet" = ncol(series_data) > 1
  )
  if (length(empty_series) != 0)
    messages <-
    c(
      messages,
      "Series for which all observations are suppressed or missing have been removed"
    )
  
  # Remove/restrict original series that are:
  # - suppressed or missing in the middle
  # - too long
  # - too short
  orig_seriesIDs <- series_metadata |>
    filter(.data$series_type == "Original") |>
    pull(.data$series_id) |> # Extract series IDs for original series
    setdiff(empty_series) # Remove empty series
  partial_series <-
    NULL # Remove these series (X-13ARIMA-SEATS in both the 'RJDemetra' and 'seasonal' packages cannot handle missing observations, so remove)
  long_series <-
    NULL # Restrict these series (X-13ARIMA-SEATS in the 'seasonal' package will fail if series is too long, so select most recent data)
  short_series <-
    NULL # Remove these series (X-13ARIMA-SEATS in both the 'RJDemetra' and 'seasonal' packages will fail if series is too short, so remove)
  max_series_length <-
    500 # This must be > 12 * min_series_length for logic below to make sense
  min_series_length <- 3
  for (seriesID in orig_seriesIDs) {
    trimmed_series <- na.trim(series_data[, seriesID])
    len_trimmed_series <- nrow(trimmed_series)
    
    # Check for partial series
    if (any(is.na(trimmed_series))) {
      partial_series <- c(partial_series, seriesID)
      next # If series is partial, then don't check for being too long or too short since it will be removed anyway
    }
    
    # Check for long series
    if (len_trimmed_series > max_series_length) {
      long_series <- c(long_series, seriesID)
      index <- len_trimmed_series - max_series_length
      series_data[1:index, seriesID] <-
        NA # Make missing the back history of the series that is too old
      next # Series can't be both too long and too short
    }
    
    # Check for short series
    if ((freq_num == 4 &
         len_trimmed_series < 4 * min_series_length) |
        (freq_num == 12 &
         len_trimmed_series < 12 * min_series_length))
      short_series <- c(short_series, seriesID)
  }
  series_data <-
    select(series_data, -(all_of(c(
      partial_series, short_series
    ))))
  stopifnot(
    "After removing original series that are too short or with suppressed or missing observations in the middle of them, no series exist in the series data sheet" = ncol(series_data) > 1
  )
  if (length(partial_series) != 0)
    messages <-
    c(
      messages,
      "Original series with suppressed or missing observations in the middle of them have been removed"
    )
  if (length(long_series) != 0)
    messages <-
    c(
      messages,
      "Original series that are too long have been restricted to the most recent 500 observations"
    )
  if (length(short_series) != 0)
    messages <-
    c(
      messages,
      "Original series that are shorter than three year's worth of data have been removed"
    )
  
  # Remove series from metadata
  series_metadata <- series_metadata |>
    filter(!(
      .data$series_id %in% c(empty_series, partial_series, short_series)
    ))
  
  # Keep only seasonally adjusted and trend series that have a corresponding original series
  nrow_before_excluding <- nrow(series_metadata)
  dataItems_tokeep <-
    series_metadata$data_item_description[series_metadata$series_type == "Original"]
  series_metadata <- series_metadata |>
    filter(.data$data_item_description %in% dataItems_tokeep)
  stopifnot(
    "After removing seasonally adjusted and/or trend series without a corresponding original series, no series remain" = nrow(series_metadata) > 0
  )
  nrow_after_excluding <- nrow(series_metadata)
  if (nrow_before_excluding != nrow_after_excluding)
    messages <-
    c(
      messages,
      "Seasonally adjusted and/or trend series without a corresponding original series have been removed"
    )
  seriesIDs_tokeep <- series_metadata$series_id
  series_data_IDs <-
    colnames(series_data)[-1] # Use this to preserve original ordering in data sheet
  seriesIDs_tokeep <- intersect(series_data_IDs, seriesIDs_tokeep)
  series_data <- series_data |>
    select(any_of(c("period", seriesIDs_tokeep)))
  if (length(setdiff(series_metadata$series_type, "Original")) == 0 &
      orig_msg_flag == FALSE)
    messages <-
    c(messages, "After data cleaning, only original series exist")
  
  # Check for matching series IDs in the series data and metadata
  data_seriesIDs <- colnames(select(series_data, -"period"))
  meta_seriesIDs <- series_metadata$series_id
  stopifnot(
    "After data cleaning, the series IDs do not match across the series data and metadata sheets" = length(setdiff(data_seriesIDs, meta_seriesIDs)) == 0
  )
  
  # Create start and end dates variables
  seriesIDs <- series_metadata$series_id
  series_metadata <- series_metadata |>
    mutate(
      start = NA,
      start_year = NA,
      start_period = NA,
      end = NA,
      end_year = NA,
      end_period = NA
    )
  for (seriesID in seriesIDs) {
    # Extract sub-span containing non-missing data
    nonmissing_span <-
      series_data[!is.na(series_data[, seriesID]), "period"]$period
    nonmissing_span <- as.Date(nonmissing_span)
    
    # Create start date variables on series metadata
    span_start <- first(nonmissing_span)
    series_metadata[series_metadata$series_id == seriesID, "start"] <-
      span_start
    series_metadata[series_metadata$series_id == seriesID, "start_year"] <-
      year(ymd(span_start))
    series_metadata[series_metadata$series_id == seriesID, "start_period"] <-
      ifelse(freq_num == 12, month(ymd(span_start)), quarter(ymd(span_start)))
    
    # Create end date variables on series metadata
    span_end <- last(nonmissing_span)
    series_metadata[series_metadata$series_id == seriesID, "end"] <-
      span_end
    series_metadata[series_metadata$series_id == seriesID, "end_year"] <-
      year(ymd(span_end))
    series_metadata[series_metadata$series_id == seriesID, "end_period"] <-
      ifelse(freq_num == 12, month(ymd(span_end)), quarter(ymd(span_end)))
  }
  
  # Create variables for the publication and table titles
  titles <-
    read_excel(
      raw_data,
      sheet = "Index",
      range = "B5:B6",
      col_names = FALSE,
      .name_repair = "unique_quiet"
    )
  title_pub <- as.character(titles[1, 1])
  title_tab <- as.character(titles[2, 1])
  series_metadata <- series_metadata |>
    mutate(publication = title_pub,
           table = title_tab)
  
  # Generate list of series data and metadata
  results <- list(data = series_data, meta = series_metadata)
  
  # Return messages
  for (message in messages)
    message(message)
  
  return(results)
}
```

```{r function-check_series, eval=FALSE}
#' @title
#' Check if a series object is in the expected format
#' 
#' @description
#' `check_series` checks if an object conforms to the format as per the list
#' returned from `download_ts` containing series data and metadata.
#' 
#' @details
#' An error is thrown if the object does not conform to the required format.
#' Otherwise the function returns nothing. Only limited error checking is
#' undertaken, such as checking for appropriate variable names and types.
#' Logical checks for aspects such as consistency within or between the series
#' data and metadata are not performed.
#' 
#' @param series The object to be checked
#' 
#' @importFrom lubridate is.Date
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Check the series object for validity (nothing happens if valid)
#' check_series(inventories)
#' 
#' @export
check_series <- function(series) {
  # Check series list
  stopifnot("`series` object is not a list" = is.list(series) == TRUE)
  stopifnot("Series data and/or metadata not found" = all(c("data", "meta") %in% names(series)))
  stopifnot(
    "Series data and/or metadata not of the expected class" = is.data.frame(series$data) == TRUE &
      is.data.frame(series$meta) == TRUE
  )
  
  # Check series data
  data_error <- FALSE
  if (any(duplicated(colnames(series$data))))
    data_error <- TRUE
  if (!("period" %in% names(series$data)))
    data_error <- TRUE
  if (is.Date(series$data$period) == FALSE)
    data_error <- TRUE
  data_vars <- setdiff(names(series$data), "period")
  if (is.null(data_vars))
    data_error <- TRUE
  if (!(all(grepl(
    "^[A-Z]{1}[0-9]{7,8}[A-Z]{1}$", data_vars
  ))))
    data_error <- TRUE
  if (!(all(lapply(series$data[,!(names(series$data) == "period")], class) == "numeric")))
    data_error <- TRUE
  stopifnot("Not all series data variables exist, are unique, and/or are in the right format" = data_error == FALSE)
  
  # Check series metadata
  meta_error <- FALSE
  if (any(duplicated(colnames(series$meta))))
    meta_error <- TRUE
  if (!("data_item_description" %in% colnames(series$meta)) |
      is.character(series$meta$data_item_description) == FALSE)
    meta_error <- TRUE
  if (!("end" %in% colnames(series$meta)) |
      is.Date(series$meta$end) == FALSE)
    meta_error <- TRUE
  if (!("end_period" %in% colnames(series$meta)) |
      is.numeric(series$meta$end_period) == FALSE)
    meta_error <- TRUE
  if (!("end_year" %in% colnames(series$meta)) |
      is.numeric(series$meta$end_year) == FALSE)
    meta_error <- TRUE
  if (!("freq_name" %in% colnames(series$meta)) |
      is.character(series$meta$freq_name) == FALSE)
    meta_error <- TRUE
  if (!("freq_num" %in% colnames(series$meta)) |
      is.numeric(series$meta$freq_num) == FALSE)
    meta_error <- TRUE
  if (!("publication" %in% colnames(series$meta)) |
      is.character(series$meta$publication) == FALSE)
    meta_error <- TRUE
  if (!("series_id" %in% colnames(series$meta)) |
      is.character(series$meta$series_id) == FALSE)
    meta_error <- TRUE
  if (!("series_type" %in% colnames(series$meta)) |
      is.character(series$meta$series_type) == FALSE)
    meta_error <- TRUE
  if (!("start" %in% colnames(series$meta)) |
      is.Date(series$meta$start) == FALSE)
    meta_error <- TRUE
  if (!("start_period" %in% colnames(series$meta)) |
      is.numeric(series$meta$start_period) == FALSE)
    meta_error <- TRUE
  if (!("start_year" %in% colnames(series$meta)) |
      is.numeric(series$meta$start_year) == FALSE)
    meta_error <- TRUE
  if (!("table" %in% colnames(series$meta)) |
      is.character(series$meta$table) == FALSE)
    meta_error <- TRUE
  if (!("unit" %in% colnames(series$meta)) |
      is.character(series$meta$unit) == FALSE)
    meta_error <- TRUE
  stopifnot(
    "Not all series metadata variables exist, are unique, and/or are in the right format" = meta_error == FALSE
  )
}
```

```{r function-get_seriesIDs, eval=FALSE}
#' @title
#' Get all series IDs from series metadata
#' 
#' @description
#' `get_seriesIDs` returns all series IDs in the series metadata for a
#' downloaded and cleaned table from an ABS publication (as returned by
#' `download_ts`).
#' 
#' @details
#' The series IDs are returned in an unsorted character vector, thus
#' preserving the original ordering in the series metadata ('Index' sheet of the
#' downloaded spreadsheet) for series that remain after data cleaning.
#' 
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' 
#' @return All series IDs in the metadata of a series
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Extract all series IDs
#' get_seriesIDs(inventories)
#' 
#' @export
get_seriesIDs <- function(series) {
  # Check for valid series object
  check_series(series)
  
  return(unique(series$meta$series_id))
}
```

```{r function-get_dataItems, eval=FALSE}
#' @title
#' Get all data item descriptions from series metadata
#' 
#' @description
#' `get_dataItems` returns all unique data item descriptions in the series
#' metadata for a downloaded and cleaned table from an ABS publication (as
#' returned by `download_ts`).
#' 
#' @details
#' The data item descriptions are returned in an unsorted character vector, thus
#' preserving the original ordering in the series metadata ('Index' sheet of the
#' downloaded spreadsheet) for series that remain after data cleaning.
#' 
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' 
#' @return All data item descriptions in the metadata of a series
#' 
#' @examples
#' # Load data
#' data("inventories")
#'
#' # Extract all data item descriptions
#' get_dataItems(inventories)
#' 
#' @export
get_dataItems <- function(series) {
  # Check for valid series object
  check_series(series)
  
  return(unique(series$meta$data_item_description))
}
```

```{r function-run_RJD}
#' @title
#' Generate seasonally adjusted and trend estimates via JDemetra+
#' 
#' @description
#' `run_RJD` executes the Eurostat's JDemetra+ program to generate the
#' seasonally adjusted and trend estimates for a time series object (containing
#' original estimates), and returns these in a list.
#' 
#' @details
#' Seasonal adjustment and trending are performed using the `RJDemetra`
#' interface to JDemetra+ (version 2). Execution is done using X-13 rather than
#' SEATS; otherwise all default values are used in the execution call.
#' 
#' @param ts A time series object
#' 
#' @importFrom RJDemetra x13
#' @importFrom stats is.ts
#' 
#' @return The seasonally adjusted and trend estimates generated by JDemetra+
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create original series
#' inventories_mining_orig <- create_ts(inventories, "A3531252X")
#' 
#' # Generate seasonally adjusted and trend series
#' inventories_mining_seas_tren <- run_RJD(inventories_mining_orig)
#' 
#' @export
run_RJD <- function(ts) {
  stopifnot("Argument class is not a time series object" = is.ts(ts) == TRUE)
  tryCatch({
    output <- x13(ts)
    results <- list("seas" = output$final$series[, "sa"],
                    "tren" = output$final$series[, "t"])
    return(results)
  },
  error = function(e) {
    message("JDemetra+ failed to run")
    return(NULL)
  })
}
```

```{r function-run_X13}
#' @title
#' Generate seasonally adjusted and trend estimates via X-13ARIMA-SEATS
#' 
#' @description
#' `run_X13` executes the United States Census Bureau's X-13ARIMA-SEATS program
#' to generate the seasonally adjusted and trend estimates for a time series
#' object (containing original estimates), and returns these in a list.
#' 
#' @details
#' Seasonal adjustment and trending are performed using the `seasonal` interface
#' to X-13ARIMA-SEATS. Execution is done using X-13 rather than SEATS; otherwise
#' all default values are used in the execution call.
#' 
#' @param ts A time series object
#' 
#' @importFrom seasonal seas
#' @importFrom stats is.ts
#' 
#' @return The seasonally adjusted and trend estimates generated by X-13ARIMA-SEATS
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create original series
#' inventories_mining_orig <- create_ts(inventories, "A3531252X")
#' 
#' # Generate seasonally adjusted and trend series
#' inventories_mining_seas_tren <- run_X13(inventories_mining_orig)
#' 
#' @export
run_X13 <- function(ts) {
  stopifnot("Argument class is not a time series object" = is.ts(ts) == TRUE)
  tryCatch({
    output <-
      seas(ts, x11 = "") # X11 option specifies X-11; overrides the 'seats' spec
    results <- list("seas" = output$data[, "seasonaladj"],
                    "tren" = output$data[, "trend"])
    return(results)
  },
  error = function(e) {
    message("X-13ARIMA-SEATS failed to run")
    return(NULL)
  })
}
```

```{r function-create_ts, eval=FALSE}
#' @title
#' Create a time series object for a single series
#' 
#' @description
#' `create_ts` returns a time series object for a single series in a downloaded
#' and cleaned table from an ABS publication (as returned by `download_ts`).
#' The series is identified by its series ID contained in the series metadata.
#' 
#' @details
#' To maintain consistency with other structures and functions used in this
#' package, a NULL object (rather than an error) is returned if the series ID is
#' missing.
#' 
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' @param seriesID The series ID of the series for which results are to be
#' returned
#' 
#' @importFrom dplyr filter pull
#' @importFrom rlang .data
#' @importFrom stats ts
#' 
#' @return A time series object for a single series
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create a time series object for a given series ID
#' inventories_mining_orig <- create_ts(inventories, "A3531252X")
#' 
#' @export
create_ts <- function(series, seriesID) {
  # Check for valid series object
  check_series(series)
  
  # Return NULL object if series ID is missing
  if (length(seriesID) == 0)
    return(NULL)
  
  # Check for valid series ID (if supplied)
  seriesIDs <- get_seriesIDs(series)
  stopifnot("Series ID does not exist" = seriesID %in% seriesIDs)
  
  # Extract data and metadata for series with corresponding series ID
  seriesID_data <-
    na.trim(select(series$data, all_of(c(
      "period", seriesID
    ))))
  seriesID_meta <-
    filter(series$meta,
           .data$series_id == seriesID)
  
  # Extract start/end dates and frequency
  start_year <- seriesID_meta$start_year
  start_period <- seriesID_meta$start_period
  end_year <- seriesID_meta$end_year
  end_period <- seriesID_meta$end_period
  freq_num <- seriesID_meta$freq_num
  
  # Generate time series object
  results <- ts(
    pull(seriesID_data, seriesID),
    start = c(start_year, start_period),
    end = c(end_year, end_period),
    frequency = freq_num
  )
  
  return(results)
}
```

```{r function-create_ts_comp, eval=FALSE}
#' @title
#' Generate original, seasonally adjusted and trend estimates for a single data
#' item description
#' 
#' @description
#' `create_ts_comp` returns a list containing the following for a single data
#' item description:
#' * the series metadata
#' * the original ABS series
#' * the seasonally adjusted and trend ABS series (where available)
#' * the seasonally adjusted and trend series generated by X-13ARIMA-SEATS and
#' JDemetra+
#' 
#' @details
#' Requires the data output from `download_ts`. If the ABS seasonally adjusted
#' and/or trend estimates are not published, then they will not exist in the
#' list (rather than assume NULL values, for instance).
#' 
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' @param dataItem The data item description for which results are to be returned
#' 
#' @return The series metadata, and original, seasonally adjusted and trend series,
#' for a single data item description
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create time series objects for a given data item description
#' item <- "Inventories ;  Total (State) ;  Mining ;  Current Price ;  TOTAL (SCP_SCOPE) ;"
#' inventories_ts_mining <- create_ts_comp(inventories, item)
#' 
#' @export
create_ts_comp <- function(series, dataItem) {
  # Check for valid series object
  check_series(series)
  
  # Check for valid data item description
  dataItems <- get_dataItems(series)
  stopifnot("Data item description does not exist" = dataItem %in% dataItems)
  
  # Extract metadata for series in corresponding data item description
  dataItem_meta <-
    filter(series$meta, .data$data_item_description == dataItem)
  
  # Extract series IDs
  seriesID_orig <-
    dataItem_meta$series_id[dataItem_meta$series_type == "Original"]
  seriesID_seas <-
    dataItem_meta$series_id[dataItem_meta$series_type == "Seasonally Adjusted"]
  seriesID_tren <-
    dataItem_meta$series_id[dataItem_meta$series_type == "Trend"]
  
  # Generate ABS original, seasonally adjusted and trend time series object (if published)
  ABS_orig_ts <- create_ts(series, seriesID_orig)
  ABS_seas_ts <-
    create_ts(series, seriesID_seas) # Series might not be published in ABS data
  ABS_tren_ts <-
    create_ts(series, seriesID_tren) # Series might not be published in ABS data
  
  # Generate JDemetra+ seasonally adjusted and trend time series objects (if possible)
  RJD_output <- run_RJD(ABS_orig_ts) # JDemetra+ might fail to run
  RJD_seas_ts <- RJD_output$seas # Series might not be generated
  RJD_tren_ts <- RJD_output$tren # Series might not be generated
  
  # Generate X-13ARIMA-SEATS seasonally adjusted and trend time series objects (if possible)
  X13_output <- run_X13(ABS_orig_ts) # X-13ARIMA-SEATS might fail to run
  X13_seas_ts <- X13_output$seas # Series might not be generated
  X13_tren_ts <- X13_output$tren # Series might not be generated
  
  # Return list of time series objects (if published/generated)
  results <-
    list("metadata" = dataItem_meta, "ABS_orig" = ABS_orig_ts)
  if (!is.null(ABS_seas_ts))
    results <-
    append(results, list("ABS_seas" = ABS_seas_ts))
  if (!is.null(ABS_tren_ts))
    results <-
    append(results, list("ABS_tren" = ABS_tren_ts))
  if (!is.null(RJD_seas_ts))
    results <-
    append(results, list("RJD_seas" = RJD_seas_ts))
  if (!is.null(RJD_tren_ts))
    results <-
    append(results, list("RJD_tren" = RJD_tren_ts))
  if (!is.null(X13_seas_ts))
    results <-
    append(results, list("X13_seas" = X13_seas_ts))
  if (!is.null(X13_tren_ts))
    results <-
    append(results, list("X13_tren" = X13_tren_ts))
  
  return(results)
}
```

```{r function-create_ts_table, eval=FALSE}
#' @title
#' Generate original, seasonally adjusted and trend estimates for all data
#' item descriptions
#' 
#' @description
#' `create_ts_table` returns a list of lists, each sub-list of which corresponds
#' to a single data item description, and contains the following for each one:
#' * the series metadata
#' * the original ABS series
#' * the seasonally adjusted and trend ABS series (where available)
#' * the seasonally adjusted and trend series generated by X-13ARIMA-SEATS and
#' JDemetra+
#' 
#' @details
#' Requires the data output from `download_ts`. If the ABS seasonally adjusted
#' and/or trend estimates are not published, then they will not exist in the
#' lists (rather than assume NULL values, for instance).
#' 
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' 
#' @return The series metadata, and original, seasonally adjusted and trend series,
#' for all data item descriptions
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create time series objects for all data item descriptions
#' inventories_ts_all <- create_ts_table(inventories)
#' 
#' @export
create_ts_table <- function(series) {
  # Check for valid series object
  check_series(series)
  
  # Extract series metadata
  meta <- series$meta
  
  # Extract unique data item descriptions
  dataItems <- get_dataItems(series)
  no_dataItems <- length(dataItems)
  
  # Initialise empty list
  results <- vector("list", no_dataItems)
  names(results) <- dataItems
  
  # Provide progress update
  message(paste("Processing", no_dataItems, "series..."))
  
  # Cycle through each data item description
  for (dataItem in dataItems) {
    # Provide progress update
    message(paste0(
      "Series ",
      which(dataItem == dataItems),
      "/",
      no_dataItems,
      ": \"",
      dataItem,
      "\"..."
    ))
    
    # Extract and generate time series objects for current data item description
    results[[dataItem]] <- create_ts_comp(series, dataItem)
  }
  
  return(results)
}
```

```{r function-create_tsdf_comp, eval=FALSE}
#' @title
#' Generate a long data frame of original, seasonally adjusted and trend
#' estimates for a single data item description
#' 
#' @description
#' `create_tsdf_comp` returns a list containing the following for a single data
#' item description:
#' * the series metadata
#' * a long data frame containing the original, seasonally adjusted and trend
#' estimates from the ABS, X-13ARIMA-SEATS, and JDemetra+ (where available)
#' 
#' @details
#' Requires the data output from `download_ts`. If the ABS seasonally adjusted
#' and/or trend estimates are not published, then they will not exist in the
#' long data frame (rather than assume NULL values, for instance).
#' 
#' This function is useful for converting the data into a format ready to be
#' plotted. (For example, plotting with ggplot2 requires data frames, not time
#' series objects.)
#'
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' @param dataItem The data item description for which results are to be returned
#' 
#' @importFrom lubridate ceiling_date days
#' @importFrom reshape2 melt
#' @importFrom stats time
#' @importFrom zoo as.Date
#' 
#' @return The series metadata, and long data frame of original, seasonally adjusted
#' and trend series, for a single data item description
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create long data frame for a given data item description
#' item <- "Inventories ;  Total (State) ;  Mining ;  Current Price ;  TOTAL (SCP_SCOPE) ;"
#' inventories_df_mining <- create_tsdf_comp(inventories, item)
#' 
#' @export
create_tsdf_comp <- function(series, dataItem) {
  # Check for valid series object
  check_series(series)
  
  # Check for valid data item description
  dataItems <- get_dataItems(series)
  stopifnot("Data item description does not exist" = dataItem %in% dataItems)
  
  # Extract time series objects for given data item description
  dataItem_ts <- create_ts_comp(series, dataItem)
  
  # Extract common span across series in data item description
  freq_name <- tolower(unique(dataItem_ts$metadata$freq_name))
  common_start <- min(dataItem_ts$metadata$start)
  common_end <- max(dataItem_ts$metadata$end)
  common_span <- seq(common_start, common_end, by = freq_name)
  
  # Extract original series span for seasonally adjusted and trend series generated by X-13ARIMA-SEATS and JDemetra+
  # (Spans for these series aren't available in the series data or metadata, but will always match the span of the original series since they are generated from it.)
  orig_seriesID <-
    filter(dataItem_ts$metadata, .data$series_type == "Original")$series_id
  ABS_orig_series <-
    na.trim(series$data[, c("period", orig_seriesID)])
  
  # Prepare data frame
  results <- data.frame("period" = common_span)
  
  # Merge on ABS seasonally adjusted series (if published)
  if (!is.null(dataItem_ts$ABS_seas)) {
    seas_seriesID <-
      filter(dataItem_ts$metadata,
             .data$series_type == "Seasonally Adjusted")$series_id
    ABS_seas_series <-
      na.trim(series$data[, c("period", seas_seriesID)])
    names(ABS_seas_series)[names(ABS_seas_series) == seas_seriesID] <-
      "ABS_seas"
    results <-
      merge(results, ABS_seas_series, by = "period", all = TRUE)
  }

  # Merge on seasonally adjusted series generated by and JDemetra+ (if generated)
  if (!is.null(dataItem_ts$RJD_seas)) {
    RJD_seas_series <-
      data.frame("period" = ABS_orig_series$period,
                 "RJD_seas" = as.numeric(dataItem_ts$RJD_seas))
    results <-
      merge(results, RJD_seas_series, by = "period", all = TRUE)
  }
  
  # Merge on seasonally adjusted series generated by X-13ARIMA-SEATS (if generated)
  if (!is.null(dataItem_ts$X13_seas)) {
    X13_seas_series <-
      data.frame("period" = ABS_orig_series$period,
                 "X13_seas" = as.numeric(dataItem_ts$X13_seas))
    results <-
      merge(results, X13_seas_series, by = "period", all = TRUE)
  }
  
  # Merge on ABS trend series (if published)
  if (!is.null(dataItem_ts$ABS_tren)) {
    tren_seriesID <-
      filter(dataItem_ts$metadata, .data$series_type == "Trend")$series_id
    ABS_tren_series <-
      na.trim(series$data[, c("period", tren_seriesID)])
    names(ABS_tren_series)[names(ABS_tren_series) == tren_seriesID] <-
      "ABS_tren"
    results <-
      merge(results, ABS_tren_series, by = "period", all = TRUE)
  }
  
  # Merge on trend series generated by JDemetra+ (if generated)
  if (!is.null(dataItem_ts$RJD_tren)) {
    RJD_tren_series <-
      data.frame("period" = ABS_orig_series$period,
                 "RJD_tren" = as.numeric(dataItem_ts$RJD_tren))
    results <-
      merge(results, RJD_tren_series, by = "period", all = TRUE)
  }
  
  # Merge on trend series generated by X-13ARIMA-SEATS (if generated)
  if (!is.null(dataItem_ts$X13_tren)) {
    X13_tren_series <-
      data.frame("period" = ABS_orig_series$period,
                 "X13_tren" = as.numeric(dataItem_ts$X13_tren))
    results <-
      merge(results, X13_tren_series, by = "period", all = TRUE)
  }
  
  # Convert into long data frame
  results <- melt(
    results,
    id.vars = c("period"),
    measusure.vars = c(
      "ABS_seas",
      "RJD_seas",
      "X13_seas",
      "ABS_tren",
      "RJD_tren",
      "X13_tren"
    ),
    value.name = "value",
    variable.name = "method"
  )
  
  # Return list of series metadata and data frame
  results <-
    list("metadata" = dataItem_ts$metadata, "dataframe" = results)
  
  return(results)
}
```

```{r function-create_tsdf_table, eval=FALSE}
#' @title
#' Generate a long data frame of original, seasonally adjusted and trend
#' estimates for all data item descriptions
#' 
#' @description
#' `create_tsdf_table` returns a list of lists, each sub-list of which
#' corresponds to a single data item description, and contains the following for
#' each one:
#' * the series metadata
#' * a long data frame containing the original, seasonally adjusted and trend
#' estimates from the ABS, X-13ARIMA-SEATS, and JDemetra+ (where available)
#' 
#' @details
#' Requires the data output from `download_ts`. If the ABS seasonally adjusted
#' and/or trend estimates are not published, then they will not exist in the
#' long data frames (rather than assume NULL values, for instance).
#' 
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' 
#' @return The series metadata, and long data frame of original, seasonally adjusted
#' and trend series, for all data item descriptions
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create long data frame for all data item descriptions
#' inventories_df_all <- create_tsdf_table(inventories)
#' 
#' @export
create_tsdf_table <- function(series) {
  # Check for valid series object
  check_series(series)
  
  # Extract series metadata
  meta <- series$meta
  
  # Extract unique data item descriptions
  dataItems <- get_dataItems(series)
  no_dataItems <- length(dataItems)
  
  # Initialise empty list
  results <- vector("list", no_dataItems)
  names(results) <- dataItems
  
  # Provide progress update
  message(paste("Processing", no_dataItems, "series..."))
  
  # Cycle through each data item description
  for (dataItem in dataItems) {
    # Provide progress update
    message(paste0(
      "Series ",
      which(dataItem == dataItems),
      "/",
      no_dataItems,
      ": \"",
      dataItem,
      "\"..."
    ))
    
    # Extract and generate time series objects for current data item description
    results[[dataItem]] <- create_tsdf_comp(series, dataItem)
  }
  
  return(results)
}
```

```{r function-create_tsplot_comp, eval=FALSE}
#' @title
#' Generate ggplots for seasonally adjusted and trend estimates for a single
#' data item description
#' 
#' @description
#' `create_tsplot_comp` returns a list of ggplot objects for the seasonally
#' adjusted and trend series corresponding to a single data item description in
#' a downloaded and cleaned table from an ABS publication (as returned by
#' `download_ts`). For each series type (seasonally adjusted and trend), the
#' following series will be plotted on a single graph:
#' * the ABS seasonally adjusted/trend series (if published)
#' * the seasonally adjusted/trend series generated by X-13ARIMA-SEATS (if
#' generated without error)
#' * the seasonally adjusted/trend series generated by JDemetra+ (if generated
#' without error)
#' 
#' @details
#' Requires the data output from `download_ts`. If the ABS seasonally adjusted
#' or trend estimates are not published, then a ggplot is still returned
#' containing only the seasonally adjusted or trend estimates generated by
#' X-13ARIMA-SEATS and JDemetra+. If the latter fail to be generated, the ggplot
#' will not contain them either. (A NULL object will be returned if the plot is
#' empty; that is, if none of these series are published or couldn't be
#' generated.)
#' 
#' The time series plotted on each graph might not match spans or have values
#' missing for the following reasons:
#' * suppressed or missing observations in the published ABS series
#' * series generated by X-13ARIMA-SEATS and JDemetra+ being restricted to only
#' recent observations due to the ABS original time series being too long (see
#' the `download_ts` function)
#'
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' @param dataItem The data item description for which results are to be returned
#' 
#' @importFrom ggplot2 aes element_text geom_line ggplot labs margin
#' scale_color_discrete scale_y_continuous theme xlab xlim ylab
#' @importFrom lubridate year
#' @importFrom rlang .data
#' @importFrom stringr str_squish str_wrap
#' 
#' @return The ggplot objects for the seasonally adjusted and trend series for a
#' single data item description
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create plots for a given data item description
#' item <- "Inventories ;  Total (State) ;  Mining ;  Current Price ;  TOTAL (SCP_SCOPE) ;"
#' inventories_mining_plots <- create_tsplot_comp(inventories, item)
#' 
#' @export
create_tsplot_comp <- function(series, dataItem) {
  # Check for valid series object
  check_series(series)
  
  # Check for valid data item description
  dataItems <- get_dataItems(series)
  stopifnot("Data item description does not exist" = dataItem %in% dataItems)
  
  # Extract time series data frame for given data item description
  dataItem_df <- create_tsdf_comp(series, dataItem)
  
  # Extract units for plotting purposes
  units <- as.character(unique(dataItem_df$metadata[, "unit"]))
  
  # Extract min and max values for axes to ensure same scale across seasonally adjusted and trend plots
  x_min <- min(dataItem_df$dataframe$period)
  x_max <- max(dataItem_df$dataframe$period)
  y_min <-
    min(dataItem_df$dataframe$value, na.rm = TRUE) # Might be NAs due to suppressed or missing values
  y_max <-
    max(dataItem_df$dataframe$value, na.rm = TRUE) # Might be NAs due to suppressed or missing values
  
  # Initialise empty list
  results <- list("seas" = NULL, "tren" = NULL)
  
  # Cycle through each series type
  for (type in c("seas", "tren")) {
    # Extract series to be plotted
    if (type == "seas") {
      plot_data <-
        dataItem_df$dataframe[dataItem_df$dataframe$method %in% c("ABS_seas", "RJD_seas", "X13_seas"), ]
      if (nrow(plot_data) == 0) {
        message("No seasonally adjusted plot was produced")
        next
      }
    }
    if (type == "tren") {
      plot_data <-
        dataItem_df$dataframe[dataItem_df$dataframe$method %in% c("ABS_tren", "RJD_tren", "X13_tren"), ]
      if (nrow(plot_data) == 0) {
        message("No trend plot was produced")
        next
      }
    }
    
    # Extract start and end periods for plotting purposes
    start_date <- unique(plot_data$period)[1]
    start_yr <- as.character(year(start_date))
    end_date <-
      unique(plot_data$period)[length(unique(plot_data$period))]
    end_yr <- as.character(year(end_date))
    freq_name <- tolower(unique(dataItem_df$metadata$freq_name))
    start_period <- format(unique(plot_data$period)[1], "%B")
    end_period <-
      format(unique(plot_data$period)[length(unique(plot_data$period))], "%B")
    period_qualifter <- ifelse(freq_name == "quarter", "Qtr", "")
    timespan <-
      str_squish(
        paste(
          start_period,
          period_qualifter,
          start_yr,
          "to",
          end_period,
          period_qualifter,
          end_yr
        )
      )
    
    # Extract legend labels for plotting purposes
    series_to_graph <- unique(as.character(plot_data$method))
    if (length(series_to_graph) == 3) {
      labels <- c("ABS", "RJD", "X13")
    } else if (length(series_to_graph) == 2) {
      label1 <- substr(series_to_graph[1], 0, 3)
      label2 <- substr(series_to_graph[2], 0, 3)
      labels <- c(label1, label2)
    } else {
      labels <- substr(series_to_graph, 0, 3)
    }
    
    # Generate plot object
    plot <- ggplot(
      plot_data,
      aes(
        x = .data$period,
        y = .data$value,
        group = .data$method,
        colour = .data$method
      )
    ) +
      geom_line(na.rm = TRUE) +
      labs(title = str_wrap(dataItem),
           subtitle = paste0(
             ifelse(type == "seas", "Seasonally Adjusted", "Trend"),
             " (",
             units,
             ")"
           )) +
      theme(
        plot.title = element_text(hjust = 0.5, margin = margin(10, 0, 10, 0)),
        plot.subtitle = element_text(hjust = 0.5)
      ) +
      xlab(paste0("\nABS original series span: ", timespan)) +
      ylab("") +
      xlim(x_min, x_max) +
      scale_color_discrete(name = "Method", labels = labels) +
      scale_y_continuous(limits = c(y_min, y_max),
                         labels = scales::comma)
    
    # Append plot for current series type
    results[[type]] <- plot
  }
  
  return(results)
}
```

```{r function-create_tsplot_table, eval=FALSE}
#' @title
#' Generate ggplots for seasonally adjusted and trend estimates for all data
#' item descriptions
#' 
#' @description
#' `create_tsplot_table` returns a list of ggplot objects for the seasonally
#' adjusted and trend series corresponding to all data item descriptions in a
#' downloaded and cleaned table from an ABS publication (as returned by
#' `download_ts`). For each series type (seasonally adjusted and trend) for each
#' data item description, the following series will be plotted on a single
#' graph:
#' * the ABS seasonally adjusted/trend series (if published)
#' * the seasonally adjusted/trend series generated by X-13ARIMA-SEATS (if
#' generated without error)
#' * the seasonally adjusted/trend series generated by JDemetra+ (if generated
#' without error)
#' 
#' @details
#' Requires the data output from `download_ts`. If the ABS seasonally adjusted
#' or trend estimates are not published for a given data item description, then
#' a ggplot is still returned containing only the seasonally adjusted or trend
#' estimates generated by X-13ARIMA-SEATS and JDemetra+. If the latter fail to
#' be generated, the ggplot will not contain them either. (A NULL object will be
#' returned if the plot is empty; that is, if none of these series are published
#' or couldn't be generated.)
#' 
#' The time series plotted on each graph for a given data item description might
#' not match spans or have values missing for the following reasons:
#' * suppressed or missing observations in the published ABS series
#' * series generated by X-13ARIMA-SEATS and JDemetra+ being restricted to only
#' recent observations due to the ABS original time series being too long (see
#' the `download_ts` function)
#'
#' @param series The list returned from `download_ts` containing series data and
#' metadata
#' 
#' @return The ggplot objects for the seasonally adjusted or trend series for all
#' data item descriptions
#' 
#' @examples
#' # Load data
#' data("inventories")
#' 
#' # Create plots for all data item descriptions
#' inventories_all_plots <- create_tsplot_table(inventories)
#' 
#' @export
create_tsplot_table <- function(series) {
  # Check for valid series object
  check_series(series)
  
  # Extract series metadata
  meta <- series$meta
  
  # Extract unique data item descriptions
  dataItems <- get_dataItems(series)
  no_dataItems <- length(dataItems)
  
  # Initialise empty list
  results <- vector("list", no_dataItems)
  names(results) <- dataItems
  
  # Provide progress update
  message(paste("Processing", no_dataItems, "series..."))
  
  # Cycle through each data item description
  for (dataItem in dataItems) {
    # Provide progress update
    message(paste0(
      "Series ",
      which(dataItem == dataItems),
      "/",
      no_dataItems,
      ": \"",
      dataItem,
      "\"..."
    ))
    
    # Generate and append seasonally adjusted and trend plots for current data item description
    results[[dataItem]] <- create_tsplot_comp(series, dataItem)
  }
  
  return(results)
}
```

```{r save-datasets, echo=FALSE, eval=FALSE, include=FALSE}
CPI <- download_ts("https://www.abs.gov.au/statistics/economy/price-indexes-and-inflation/consumer-price-index-australia/jun-quarter-2023/640101.xlsx")
employment <- download_ts("https://www.abs.gov.au/statistics/labour/employment-and-unemployment/labour-force-australia/jul-2023/6202001.xlsx")
GDP <- download_ts("https://www.abs.gov.au/statistics/economy/national-accounts/australian-national-accounts-national-income-expenditure-and-product/jun-2023/5206001_Key_Aggregates.xlsx")
inventories <- download_ts("https://www.abs.gov.au/statistics/economy/business-indicators/business-indicators-australia/jun-2023/5676003.xlsx")
retail <- download_ts("https://www.abs.gov.au/statistics/industry/retail-and-wholesale-trade/retail-trade-australia/jul-2023/850101.xlsx")
sales <- download_ts("https://www.abs.gov.au/statistics/economy/business-indicators/business-indicators-australia/jun-2023/5676006.xlsx")
```